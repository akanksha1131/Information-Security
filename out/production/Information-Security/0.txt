import java.util.HashMap;
import java.util.Scanner;

public class HillCipher2 {
    public static void main(String[] args) {
        HashMap<Integer, Integer> map= inversemap();
        char[] letters = {
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
        };

        int[][] key={
                {3,10,20},
                {20,9,17},
                {9,4,17}
        };
        String input=acceptInput();
        int[][] inputmatrix= createinputmatrix(input);
        int[][] keymatrix=inputMatrix(map);
        System.out.println("\nInput matrix");
        printMatrix(inputmatrix);
        System.out.println("\nKey matrix");
        printMatrix(keymatrix);
        int[][] ciphertext=multiply(inputmatrix, keymatrix);
        System.out.println("\nCipher matrix");
        printMatrix(ciphertext);
        System.out.println("\nCipher Text");
        printText(ciphertext, letters);
        int[][] decryptedmatrix= decrypt(ciphertext, keymatrix,map);
        System.out.println("\nDecrypted text");
        printText(decryptedmatrix, letters);




    }

    private static int[][] decrypt(int[][] ciphertext, int[][] keymatrix, HashMap<Integer, Integer> map) {
        int[][] inverse= inverse(ciphertext, keymatrix, map);
        int[][] ans=multiply(ciphertext, inverse);
        return ans;
    }

    private static void printText(int[][] matrix, char[] letters) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(letters[matrix[i][j]]+ " ");
            }

        }

    }

    private static int[][] inverse(int[][] c,int[][] keymatrix, HashMap<Integer, Integer> map) {
        int k = map.get(calculateDet(keymatrix));
        int[][] t= transposeMatrix(keymatrix);
        int [][] adj=adjoint(t);
        for(int i=0;i<3;i++){
            for(int j=0; j<3;j++){
                adj[i][j]*=k;
                adj[i][j]=adj[i][j]%26;
                if(adj[i][j]<0){adj[i][j]+=26;}

            }
        }
        return adj;


    }

    private static int[][] adjoint(int[][] t) {
        int[][] a= new int[3][3];
        for(int i=0;i<3;i++){
            for(int j=0; j<3;j++){
                a[i][j]=minor(t,i,j);
                if((i+j)%2==1){a[i][j]*=(-1);}
            }
        }
        return a;
    }

    private static int minor(int[][] t, int row, int col) {
        int[][] minorMatrix = new int[2][2];
        int a=0,b=0;
        for(int i=0;i<3;i++){
            if(i==row){continue;}
            for(int j=0; j<3;j++){
                if(j==col){continue;}
                minorMatrix[a][b]=t[i][j];
                if(a==0 && b==0){ a=0; b=1;}
                else if(a==0 && b==1){a=1;b=0;}
                else if(a==1 && b==0){a=1;b=1;}

            }

        }
        return minorMatrix[0][0] * minorMatrix[1][1] - minorMatrix[0][1] * minorMatrix[1][0];
        }



    private static int[][] transposeMatrix(int[][] keymatrix) {
        int[][] t= new int[3][3];
        for(int i=0;i<3;i++){
            for(int j=0; j<3;j++){
                t[j][i]=keymatrix[i][j];
            }
        }
        return t;
    }




    private static int[][] multiply(int[][] a, int[][] b) {
        int[][] ans= new int[3][3];
        for(int i=0;i<3;i++){
            for(int j=0;j<3;j++){
                for(int k=0;k<3;k++){
                    ans[i][j]+=a[i][k]*b[k][j];
                    ans[i][j]=ans[i][j]%26;

                }

            }        }
        return ans;

    }

    public static int[][] createinputmatrix(String input) {
        int[][] m = new int[3][3];
        for (int i = 0; i < 9; i++) {
            m[i/3][i%3]= (int)input.charAt(i)-65;
        }
        return m;
    }

    private static HashMap<Integer, Integer> inversemap() {
        HashMap<Integer, Integer> map= new HashMap();
        map.put(1,1);
        map.put(3,9);
        map.put(5,21);
        map.put(9,3);
        map.put(21,5);
        map.put(7,15);
        map.put(15,7);
        map.put(11,19);
        map.put(19,11);
        map.put(17,23);
        map.put(23,17);
        map.put(25,25);
        return map;

    }

    public static int[][] inputMatrix(HashMap<Integer, Integer> map) {
        int[][] matrix = new int[3][3];
        System.out.println("Enter 3x3 matrix such that det!=0 and inverse of determinant mod 26 exists");
        boolean validmatrix=false;
        while(validmatrix==false){
            Scanner scanner = new Scanner(System.in);
            System.out.println("Enter the elements of the 3x3 matrix:");
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    matrix[i][j] = scanner.nextInt();
                }
            }
            int det=calculateDet(matrix);
            if(det!=0 && inversemap().containsKey(det)){
                validmatrix=true;
            }
        }

        return matrix;
    }

    private static int calculateDet(int[][] m){
        int ans=0;
        ans = (m[0][0]*(m[1][1]*m[2][2]-m[2][1]*m[1][2]))-(m[0][1]*(m[1][0]*m[2][2]
                -m[2][0]*m[1][2]))+(m[0][2]*(m[1][0]*m[2][1]-m[2][0]*m[1][1]));
        ans=ans%26;
        if(ans<0){ans+=26;}
        //
        return ans;
    }
    private static String acceptInput() {
        String input="";
        boolean correctinput=false;
        while(correctinput==false){
            Scanner sc= new Scanner(System.in);
            System.out.println("Enter input string (9 length and capital letters)");
            input=sc.next();
            boolean uppercase=true;
            for(int i=0;i<input.length();i++){
                if(!Character.isUpperCase(input.charAt(i))){
                    uppercase=false;
                    break;
                }
            }
            if(uppercase=true && input.length()==9){
                correctinput=true;
            }
        }
        return input;
    }
    public static void printMatrix(int[][] matrix) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }
}


import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class DES {

    private static final String ALGORITHM = "DES";
    private static final byte[] keyValue =
            new byte[] { 'S','d','t','r','e','t','h','f'};

    public static String encrypt(String data) {
        try {
            SecretKeySpec key = new SecretKeySpec(keyValue, ALGORITHM);
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] encryptedBytes = cipher.doFinal(data.getBytes());
            return Base64.getEncoder().encodeToString(encryptedBytes);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String decrypt(String encryptedData) {
        try {
            SecretKeySpec key = new SecretKeySpec(keyValue, ALGORITHM);
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, key);
            byte[] decodedBytes = Base64.getDecoder().decode(encryptedData);
            byte[] decryptedBytes = cipher.doFinal(decodedBytes);
            return new String(decryptedBytes);

        }
        catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        String data = "attack at 10 pm";
        String encryptedData = DES2.encrypt(data);
        String decryptedData = DES2.decrypt(encryptedData);
        System.out.println("Original Data: " + data);
        System.out.println("Encrypted Data: " + encryptedData);
        System.out.println("Decrypted Data: " + decryptedData);
    }
}

public class AdditiveCipher {
    public static String acceptInput() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String input (capital letters):");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Input = "+input);
        return input;
    }

    public static boolean checkInputCorrect(String input) {
        return input.matches("[A-Z]+");
    }

    public static int acceptKey() {
        int key = 0;
        boolean correctKey = false;
        do {
            System.out.println("Enter Key (an integer):");
            Scanner sc = new Scanner(System.in);
            if (sc.hasNextInt()) {
                key = sc.nextInt();
                correctKey = true;
            } else {
                System.out.println("Invalid input. Key should be an integer.");
            }
        } while (!correctKey);
        System.out.println("Key = " + key);
        return key;
    }

    public static String encrypt(String input, int key, char[] capitalLetters) {
        StringBuilder encryptedString = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char ch = input.charAt(i);
            int index = ch - 'A'; // Convert character to 0-based index
            int encryptedIndex = (index + key) % 26; // Apply the additive cipher formula
            if (encryptedIndex < 0) {
                encryptedIndex += 26; // Handle negative indices
            }
            encryptedString.append(capitalLetters[encryptedIndex]);
        }
        System.out.println("Encrypted String = " + encryptedString);
        return encryptedString.toString();
    }

    public static String decrypt(String input, int key, char[] capitalLetters) {
        StringBuilder decryptedString = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char ch = input.charAt(i);
            int index = ch - 'A'; // Convert character to 0-based index
            int decryptedIndex = (index - key) % 26; // Apply the additive cipher formula
            if (decryptedIndex < 0) {
                decryptedIndex += 26; // Handle negative indices
            }
            decryptedString.append(capitalLetters[decryptedIndex]);
        }
        System.out.println("Decrypted String = " + decryptedString);
        return decryptedString.toString();
    }

    public static void main(String[] args) {
        char[] capitalLetters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
        int key = acceptKey();
        String input = acceptInput();
        String encrypted = encrypt(input, key, capitalLetters);
        decrypt(encrypted, key, capitalLetters);
    }
}


import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class MultiplicativeCipher {
    public static String acceptInput() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String input (capital letters)  :");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Input = "+input);
        return input;

    }

    public static boolean checkInputCorrect(String input) {
        boolean correctInput=true;
        for(int i=0; i<input.length(); i++){
            if(!Character.isUpperCase(input.charAt(i))){
                correctInput=false;
                break;
            }
        }
        return correctInput;

    }

    public static int acceptKey(HashMap <Integer, Integer>  map) {

        boolean correctkey=false;
        int key=-1;
        do{
            System.out.println("Enter Key:");
            try{
                Scanner sc= new Scanner(System.in);
                key=sc.nextInt();
            }
            catch(Exception e){
                System.out.println("Key should be an integer with a multiplication inverse in mode 26. Try again.");

            }
            if(map.containsKey(key)||map.containsValue(key)){
                correctkey=true;

            }
        }
        while(!correctkey);
        System.out.println("Key = "+key);
        return key;


    }

    public static String encrypt(String input, int key, char[] capitalLetters) {
        StringBuilder ans = new StringBuilder();
        int n = input.length();
        for(int i=0; i<n; i++){
            int p = (int)input.charAt(i);
            int c =  ((p-65)*key)%26;
            ans.append(capitalLetters[c]);
        }
        String encrypted = ans.toString();
        System.out.println("Encrypted String = "+encrypted);
        return encrypted;

    }

    public static String decrypt(String input, int key, char[] capitalLetters) {
        StringBuilder ans = new StringBuilder();
        int n = input.length();
        for(int i=0; i<n; i++){
            int p = (int)input.charAt(i);
            int c =  ((p-65)*key)%26;
            if(c<0){
                c+=26;
            }
            ans.append(capitalLetters[c]);
        }
        String decrypted = ans.toString();
        System.out.println("Decrypted String = "+decrypted);
        return decrypted;
    }
    public static void multiplicativeCipher(HashMap <Integer, Integer>  map, char[] capitalLetters) {
        int key = acceptKey(map);
        String input= acceptInput();
        String encrypted = encrypt(input, key, capitalLetters);
        int dkey=-1;
        if(map.containsKey(key)){
            dkey=map.get(key);
        }
        else {
            for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                if(entry.getValue() == key){
                    dkey=entry.getKey();
                    break;
                }
            }
            if(dkey==-1){}
        }
        System.out.println("Decryption Key = "+dkey);
        String decrypted = decrypt(encrypted, dkey, capitalLetters);
    }

    public static void main(String[] args) {
        HashMap <Integer, Integer>  map = new HashMap<>();
        map.put(1,1);
        map.put(3,9);
        map.put(5,21);
        map.put(7,15);
        map.put(11,19);
        map.put(17,23);
        map.put(25,25);
        char[] capitalLetters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
        multiplicativeCipher(map, capitalLetters);



    }
}

public class Playfair {
    public static void main(String[] args) {
        char[] capitalLetters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M',
                'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
        playfair(capitalLetters);

    }

    public static void playfair(char[] capitalLetters) {
        String input = acceptInput();
        String finalinput = processInput(input);
        System.out.println("Processed input = " + finalinput);
        String key = acceptKey();
        char[][] m = createMatrix(key, capitalLetters);
        String encrypted = encrypt(finalinput, m);
        System.out.println("ENCRYPTED TEXT = "+encrypted);
        String decrypted = decrypt(encrypted, m);
        System.out.println("DECRYPTED TEXT = "+decrypted);

    }

    public static String decrypt(String input, char[][] m){
        StringBuilder ans= new StringBuilder();
        for(int i=0; i<=input.length()-2; i=i+2){
            int c1_row= findRow(input.charAt(i),m);
            int c1_col=findCol(input.charAt(i),m);
            int c2_row= findRow(input.charAt(i+1),m);
            int c2_col=findCol(input.charAt(i+1),m);

            int newc1col = (c1_col-1)%5;
            if(newc1col<0){newc1col+=5;}
            int newc2col = (c2_col-1)%5;
            if(newc2col<0){newc2col+=5;}
            int newc1row=(c1_row-1)%5;
            if(newc1row<0){newc1row+=5;}
            int newc2row=(c2_row-1)%5;
            if(newc2row<0){newc2row+=5;}

            if(c1_row==c2_row){

                ans.append(m[c1_row][newc1col]);
                ans.append(m[c2_row][newc2col]);
            }
            else if(c1_col==c2_col){
                ans.append(m[newc1row][c1_col]);
                ans.append(m[newc2row][c2_col]);

            }
            else{
                ans.append(m[c1_row][c2_col]);
                ans.append(m[c2_row][c1_col]);

            }

//            System.out.println(input.charAt(i)+" "+input.charAt(i+1));
//            System.out.println(ans.toString());
        }
        return ans.toString();

    }

    public static String encrypt(String input, char[][] m){
        StringBuilder ans= new StringBuilder();
        for(int i=0; i<=input.length()-2; i=i+2){
            int c1_row= findRow(input.charAt(i),m);
            int c1_col=findCol(input.charAt(i),m);
            int c2_row= findRow(input.charAt(i+1),m);
            int c2_col=findCol(input.charAt(i+1),m);
            if(c1_row==c2_row){
               ans.append(m[c1_row][(c1_col+1)%5]);
               ans.append(m[c2_row][(c2_col+1)%5]);
            }
            else if(c1_col==c2_col){
                ans.append(m[(c1_row+1)%5][c1_col]);
                ans.append(m[(c2_row+1)%5][c2_col]);

            }
            else{
                ans.append(m[c1_row][c2_col]);
                ans.append(m[c2_row][c1_col]);

            }
//            System.out.println(input.charAt(i)+" "+input.charAt(i+1));
//            System.out.println(ans.toString());
        }
        return ans.toString();

    }

    private static boolean sameRow(int i, int i2, char[][] m, String input) {
        boolean ans=false;
        if(findRow(input.charAt(i),m)==findRow(input.charAt(i2),m)){
            ans=true;
        }
        return  ans;
    }

    private static boolean sameColumn(int i, int i2, char[][] m,  String input) {
        boolean ans=false;
        if(findCol(input.charAt(i),m)==findCol(input.charAt(i2),m)){
            ans=true;
        }
        return  ans;
    }

    private static int findRow(char c, char[][] m){
        int row=-1;
        for(int i=0;i<m.length;i++){
            for(int j=0;j<m[0].length;j++){
                if(m[i][j]==c){
                    row=i;
                }
            }
        }
        return row;

    }
    private static int findCol(char c, char[][] m){
        int col=-1;
        for(int i=0;i<m.length;i++){
            for(int j=0;j<m[0].length;j++){
                if(m[i][j]==c){
                    col=j;
                }

            }
        }
        return col;

    }

    private static char[][] createMatrix(String key, char[] capitalLetters) {
        char[][] m= new char[5][5];
        Set<Character> s = new LinkedHashSet<>();
        //adding key char to set
        for (int i=0; i<key.length();i++){
            s.add(key.charAt(i));
        }

        //adding rest chars to set
        for (int i=0; i< capitalLetters.length;i++){
            s.add(capitalLetters[i]);
        }

        int i=0; int j=0;
        for(char c: s){
            m[i/5][j%5]=c;
            i++;
            j++;
        }
        printCharArray(m);
        return m;

    }

    private static String processInput(String input) {
       StringBuilder ans= new StringBuilder();
       List<Character> ls= new LinkedList<>();
       int[] visited= new int[input.length()];
       int i=0;
       while(i<input.length()-1){
           if(input.charAt(i)!=input.charAt(i+1)){
               ans.append(input.charAt(i));
               visited[i]=1;
               ans.append(input.charAt(i+1));
               visited[i+1]=1;
               i=i+2;

           }
           else{
               ans.append(input.charAt(i));
               visited[i]=1;
               ans.append('X');
               i=i+1;
           }
       }
       if(visited[input.length()-1]==0){
           if(ans.length()%2==0){
               ans.append(input.charAt(input.length()-1));
               visited[input.length()-1]=1;
               ans.append('X');
           }
           else{
               ans.append('X');
           }
       }



       return ans.toString();
    }


    public static void printCharArray(char[][] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println(); // Move to the next line after printing each row
        }
    }

    public static String acceptKey() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String key (capital letters)  :");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Key = "+input);
        return input;

    }
    public static String acceptInput() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String input (capital letters)  :");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Input = "+input);
        return input;

    }

    public static boolean checkInputCorrect(String input) {
        boolean correctInput=true;
        for(int i=0; i<input.length(); i++){
            if(!Character.isUpperCase(input.charAt(i))){
                correctInput=false;
                break;
            }
        }
        return correctInput;

    }
}

public class Railfence {
    public static void main(String[] args) {
        String input=acceptInput();
        int key=acceptKey();
        String encrypted=encrypt(input,key);
        System.out.println("ENCRYPTED TEXT = "+encrypted);
        String decrypted = decrypt(encrypted, key);
        System.out.println("DECRYPTED TEXT = "+decrypted);
    }

    private static String decrypt(String input, int key) {
        StringBuilder ans=new StringBuilder();
        int rows=key;
        int col=input.length();
        char[][] m= new char[rows][col];

        for(int i=0;i<rows;i++){
            for(int j=0;j<col;j++){
                m[i][j]='.';
            }
        }
        int c=0;
        int i=0;
        int n=input.length();
        boolean goUp=false;
        while(i<n){
            m[c][i]='+';
            if(c==0){goUp=false;}
            else if(c==key-1){goUp=true;}
            if(goUp){
                c--;
            }
            else{
                c++;
            }
            i++;
        }

        int w=0;
        for(int x=0; x<rows;x++){
            for(int y=0;y<col;y++){
                if(m[x][y]=='+'){
                    m[x][y]=input.charAt(w);
                    w++;
                }
            }
        }

        for(int y=0;y<col;y++){
            for(int x=0; x<rows;x++){
                if(m[x][y]!='.'){
                    ans.append(m[x][y]);

                }
            }
        }
        return ans.toString();

    }

    private static String encrypt(String input, int key) {
        StringBuilder ans=new StringBuilder();
        int rows=key;
        int col=input.length();
        char[][] m= new char[rows][col];

        for(int i=0;i<rows;i++){
            for(int j=0;j<col;j++){
                m[i][j]='.';
            }
        }
        int c=0;
        int i=0;
        int n=input.length();
        boolean goUp=false;
        while(i<n){
            m[c][i]=input.charAt(i);
            if(c==0){goUp=false;}
            else if(c==key-1){goUp=true;}
            if(goUp){
                c--;
            }
            else{
                c++;
            }
            i++;
        }
        printCharArray(m);
        for(int x=0; x<rows;x++){
            for(int y=0;y<col;y++){
                if(m[x][y]!='.'){
                    ans.append(m[x][y]);
                }
            }
        }
        return ans.toString();

    }
    public static void printCharArray(char[][] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println(); // Move to the next line after printing each row
        }
    }

    public static int acceptKey() {
        int key = 0;
        boolean correctKey = false;
        do {
            System.out.println("Enter Key (an integer):");
            Scanner sc = new Scanner(System.in);
            if (sc.hasNextInt()) {
                key = sc.nextInt();
                correctKey = true;
            } else {
                System.out.println("Invalid input. Key should be an integer.");
            }
        } while (!correctKey);
        System.out.println("Key = " + key);
        return key;
    }

    public static String acceptInput() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String input (capital letters)  :");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Input = "+input);
        return input;

    }

    public static boolean checkInputCorrect(String input) {
        boolean correctInput=true;
        for(int i=0; i<input.length(); i++){
            if(!Character.isUpperCase(input.charAt(i))){
                correctInput=false;
                break;
            }
        }
        return correctInput;

    }
}


public class Columnar {
    public static void main(String[] args) {
        String input=acceptInput();
        int[] key=acceptKey();
        columnar(input,key);
    }
    public  static void columnar(String input, int[] key){
        String encrypted= encrypt(key, input);
        String decrypted=decrypt(key, encrypted);
    }

    private static String decrypt(int[] key, String input) {
        StringBuilder ans= new StringBuilder();
        char[][] m= new char[input.length()/key.length][key.length];
        int rows=input.length()/ key.length;
        int n = key.length;

        for(int i=0;i< input.length();i++){
            int col=findCol((i/rows)+1,key);
            int row= i%rows;
            m[row][col]=input.charAt(i);
        }
        System.out.println();
        printCharArray(m);

        for(int i=0;i<rows;i++){
            for(int j=0;j<key.length;j++){
                ans.append(m[i][j]);
            }
        }
        String decrypted=ans.toString();
        System.out.println("Decrypted text = "+decrypted);
        return decrypted;

    }

    public static String encrypt(int[] key, String input){
        StringBuilder ans= new StringBuilder();
        int n=key.length;
        int rows=0;
        if(input.length() % n==0){
            rows=input.length()/n;
        }
        else{
            rows=input.length()/n +1;
        }
        int x=0;
        if(input.length()%n!=0){
            x= (n*((input.length()/n) +1))-input.length();

        }
        String input2=input;
        for(int i=0;i<x;i++){
            input2=input2+"X";
        }
//        System.out.println("Input becomes = "+input2);
//        System.out.println("new input length = "+input2.length());

        char[][] m= new char[rows][n];

        for(int i=0; i<input2.length();i++){
            m[i/n][i%n]=input2.charAt(i);
        }
//
        for(int i=0;i< key.length;i++){
            int col=findCol(i+1,key);
            for(int j=0; j<rows;j++){
                ans.append(m[j][col]);
            }
        }
        System.out.println("Encrypted text = "+ans.toString());
        return ans.toString();
    }

    private static int findCol(int j, int[] key) {
        int col=-1;
        for(int i=0;i< key.length;i++){
            if(key[i]==j){
                col=i;
                break;
            }
        }
        return col;
    }


    public static void printCharArray(char[][] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println(); // Move to the next line after printing each row
        }
    }
    public static int[] acceptKey(){
        Scanner sc= new Scanner(System.in);
        System.out.println("Enter number of columns");
        int n=sc.nextInt();
        int[] key=new int[n];
        System.out.println("Enter column numbers between 1 to "+n);
        for(int i=0; i<n;i++){
            key[i]=sc.nextInt();
        }
        return key;
    }
    public static String acceptInput() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String input (capital letters)  :");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Input = "+input);
        return input;

    }

    public static boolean checkInputCorrect(String input) {
        boolean correctInput=true;
        for(int i=0; i<input.length(); i++){
            if(!Character.isUpperCase(input.charAt(i))){
                correctInput=false;
                break;
            }
        }
        return correctInput;

    }
}

import java.util.Scanner;

public class Vigenere {
    public static void main(String[] args) {
        char[] capitalLetters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
        vigenere(capitalLetters);
    }

    private static void vigenere(char[] capitalLetters) {
        String input = acceptInput();
        String key = acceptKey();
        String encrypted = encrypt(input, key, capitalLetters);
        System.out.println("ENCRYPTED TEXT = " + encrypted);
        String decrypted = decrypt(encrypted, key, capitalLetters);
        System.out.println("DECRYPTED TEXT = " + decrypted);
    }

    private static String decrypt(String input, String key, char[] capitalLetters) {
        StringBuilder ans = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char p = input.charAt(i);
            char k = key.charAt(i % key.length());
            int j = ((int) p - (int) k - 130) % 26;
            if (j < 0) {
                j += 26;
            }
            ans.append(capitalLetters[j]);

        }
        return ans.toString();
    }

    private static String encrypt(String input, String key, char[] capitalLetters) {
        StringBuilder ans = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char p = input.charAt(i);
            char k = key.charAt(i % key.length());
            int j = ((int) p + (int) k - 130) % 26;
            ans.append(capitalLetters[j]);

        }
        return ans.toString();
    }

    public static String acceptKey() {
        Scanner sc = new Scanner(System.in);
        boolean correctInput = false;
        String input = "";
        do {
            System.out.println("Enter String key (capital letters)  :");
            input = sc.next();
            if (checkInputCorrect(input)) {
                correctInput = true;
            }
        }
        while (!correctInput);
        System.out.println("Key = " + input);
        return input;

    }

    public static String acceptInput() {
        Scanner sc = new Scanner(System.in);
        boolean correctInput = false;
        String input = "";
        do {
            System.out.println("Enter String input (capital letters)  :");
            input = sc.next();
            if (checkInputCorrect(input)) {
                correctInput = true;
            }
        }
        while (!correctInput);
        System.out.println("Input = " + input);
        return input;

    }

    public static boolean checkInputCorrect(String input) {
        boolean correctInput = true;
        for (int i = 0; i < input.length(); i++) {
            if (!Character.isUpperCase(input.charAt(i))) {
                correctInput = false;
                break;
            }
        }
        return correctInput;
    }
}
